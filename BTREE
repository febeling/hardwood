
    %% Fun = fun(A, AccIn) -> {B, AccOut}
    %% mapfoldl(F, Acc, L) -> {L1, Acc1}

     C     G     M
 AB    DEF   HIL   NOP


       

     C  K
   [] [] []

Split Node
  find median key
  move median key to parent
  remove node as child from parent
  create 2 new nodes
    move keys to 2 new nodes (upper, lower)
    move childs to 2 new nodes (upper, lower)
  insert 2 new nodes as childs into parent

Number of childs = Number Keys + 1

New parent key: 2          [1, 2*, 3]
New parent childs: 2, 3  [1, 2*, 3*, 4]



to_gv(Node) -> 
     KeyToLabelF = "
     Labels = map(KeyToLabelF, Keys)
"struct~p [label="~p"]", [NodeIndex, ]

to_label(Keys) ->
  
--------------------------------------------------
	
   
render_node(Node, SeqNum)
render_keys(Keys)

%% {NodeStrings, EdgeStrings} =
render_childs(Node, NodeID, NodeStrings, EdgeStrings, NodeCount)
  NodeStringsM = [render_node(Node, NodeCount), "\n" | NodeStrings],

  EdgeStringsM = [render_edges(Node, NodeCount), "\n" | EdgeStrings],


render_childs(#node{leaf=false}=Node, ParentNodeCount) ->
  Node#node.childs
  NodeCountSeq = lists:seq(NodeCount + 1, NodeCount + length(Node#node.childs)),
  ChildNodeIDs = lists:map(fun(N) -> io_lib:format("struct~p", [N]) end, NodeCountSeq),
  Acc = {NodeStrings, EdgeStrings, NodeCount}
  mapfoldl(render_rec, )

      
